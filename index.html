<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Retro Bomber Arena - Boss Battle</title>
    <style>
        :root {
            --bg-color: #2c2c54; 
            --ui-bg: #40407a;
            --text-color: #ffffff;
            --accent: #ffda79;
            --danger: #ff5252;
            --success: #33d9b2;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            user-select: none;
            overscroll-behavior: none;
        }

        #game-container {
            position: relative;
            background-color: #4cd137;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            width: auto;
            height: 90vh;
            aspect-ratio: 13/11;
            border: 4px solid #f7f1e3;
        }

        @media (max-width: 900px) {
            #game-container {
                border: none;
                height: 100vh;
                width: auto;
                max-width: 100%;
                aspect-ratio: 13/11;
            }
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            width: 100%;
            height: 100%;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(44, 44, 84, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            text-align: center;
        }

        .hidden {
            display: none !important;
        }

        h1 {
            font-size: 3rem;
            color: var(--accent);
            text-shadow: 4px 4px #222;
            margin-bottom: 10px;
            font-family: 'Verdana', sans-serif;
            font-style: italic;
        }
        
        @media (max-width: 600px) {
            h1 { font-size: 2rem; }
        }

        .btn {
            background: var(--ui-bg);
            color: #fff;
            border: 2px solid #fff;
            padding: 12px 25px;
            font-size: 1.1rem;
            margin: 8px;
            cursor: pointer;
            font-family: inherit;
            transition: transform 0.1s, background 0.2s;
            min-width: 200px;
            -webkit-tap-highlight-color: transparent;
            border-radius: 8px;
            box-shadow: 0 4px 0 #222;
        }

        .btn:active { transform: scale(0.95) translateY(4px); box-shadow: 0 0 0 #222; }

        .btn:hover {
            background: #706fd3;
            border-color: var(--accent);
            color: var(--accent);
        }

        .btn-small {
            padding: 5px 15px;
            font-size: 0.9rem;
            min-width: auto;
            margin: 5px;
        }

        .settings-box {
            background: rgba(255,255,255,0.1);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .setting-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 280px;
        }
        
        @media (max-width: 400px) {
            .setting-row { width: 100%; }
        }

        .toggle-btn {
            background: #555;
            border: 1px solid #888;
            color: #bbb;
        }
        .toggle-btn.active {
            background: var(--accent);
            color: #2c2c54;
            border-color: #fff;
            font-weight: bold;
        }

        #editor-ui {
            z-index: 30;
            background: rgba(44, 44, 84, 0.98);
        }

        #editor-grid {
            display: grid;
            grid-template-columns: repeat(13, 1fr);
            grid-template-rows: repeat(11, 1fr);
            gap: 1px;
            background: #222;
            padding: 5px;
            border: 2px solid #666;
            margin-bottom: 10px;
            width: 90%;
            max-width: 600px;
            aspect-ratio: 13/11;
        }

        .editor-cell {
            background: #4cd137;
            border: 1px solid rgba(0,0,0,0.1);
            cursor: pointer;
        }
        .cell-wall { background-color: #718093; }
        .cell-soft { background-color: #e1b12c; }
        .cell-floor { background-color: #4cd137; }
        .cell-spawn { 
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 10 10"><text y="8" font-size="8">üö©</text></svg>'); 
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0.7;
        }

        .controls-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 10px;
            text-align: left;
            font-size: 0.85rem;
            background: rgba(255,255,255,0.1);
            padding: 15px;
            border-radius: 8px;
        }

        .key {
            display: inline-block;
            background: #ddd;
            color: #000;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.8rem;
            box-shadow: 0 2px 0 #888;
        }

        #hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            display: flex;
            justify-content: space-between;
            pointer-events: none;
            z-index: 15;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.5);
            font-weight: bold;
            font-size: 1.1rem;
            font-family: 'Verdana', sans-serif;
        }

        .player-stat {
            display: flex;
            gap: 10px;
            background: rgba(0,0,0,0.4);
            padding: 5px 12px;
            border-radius: 20px;
            align-items: center;
            border: 2px solid rgba(255,255,255,0.2);
        }

        #level-info {
            color: var(--accent);
            font-size: 1.8rem;
            text-shadow: 3px 3px 0 #2c2c54;
            font-style: italic;
        }

        #game-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4rem;
            font-weight: bold;
            color: #ffda79;
            text-shadow: 4px 4px 0 #2c2c54, -2px -2px 0 #ff5252;
            pointer-events: none;
            z-index: 15;
            white-space: nowrap;
            text-align: center;
        }
        
        .p1-color { color: #ff5252; }
        .p2-color { color: #34ace0; }

        /* Mobile Controls */
        #mobile-controls {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 50;
            pointer-events: none;
        }

        @media (hover: none) and (pointer: coarse) {
            #mobile-controls { display: block; }
            .controls-info { display: none; }
        }

        .control-group {
            position: absolute;
            bottom: 40px; 
            pointer-events: auto;
            padding-bottom: env(safe-area-inset-bottom); 
        }

        .d-pad-container {
            left: 40px;
            padding-left: env(safe-area-inset-left);
        }

        .action-container {
            right: 110px; 
            bottom: 160px; 
            padding-right: env(safe-area-inset-right);
        }

        .d-pad {
            position: relative;
            width: 160px;
            height: 160px;
            background: rgba(0,0,0,0.15);
            border-radius: 50%;
            border: 2px solid rgba(255,255,255,0.2);
        }

        .touch-btn {
            position: absolute;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.25);
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            user-select: none;
            -webkit-user-select: none;
            color: rgba(255,255,255,1);
            box-shadow: 0 4px 0 rgba(0,0,0,0.2);
        }

        .touch-btn:active, .touch-btn.active {
            background: var(--accent);
            color: #2c2c54;
            transform: scale(0.95) translateY(4px);
            box-shadow: none;
        }

        .btn-up { top: 5px; left: 55px; }
        .btn-down { bottom: 5px; left: 55px; }
        .btn-left { top: 55px; left: 5px; }
        .btn-right { top: 55px; right: 5px; }

        .btn-bomb-touch {
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: rgba(255, 82, 82, 0.6);
            border: 4px solid rgba(255, 255, 255, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 40px;
            color: white;
            box-shadow: 0 6px 0 rgba(180, 0, 0, 0.5);
        }
        .btn-bomb-touch:active, .btn-bomb-touch.active {
            background: #ff5252;
            transform: scale(0.95) translateY(4px);
            box-shadow: none;
        }

        #rotate-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #2c2c54;
            z-index: 100;
            color: white;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        #rotate-icon {
            font-size: 80px;
            margin-bottom: 20px;
            animation: rotate-anim 2s infinite;
        }

        @keyframes rotate-anim {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(90deg); }
            50% { transform: rotate(90deg); }
            75% { transform: rotate(0deg); }
            100% { transform: rotate(0deg); }
        }

        @media screen and (orientation: portrait) and (max-width: 900px) {
            #rotate-overlay { display: flex; }
            #mobile-controls { display: none; }
        }

    </style>
</head>
<body>

    <div id="rotate-overlay">
        <div id="rotate-icon">üì±‚û°Ô∏è</div>
        <h2>Ë´ãÂ∞áÊâãÊ©üËΩâÁÇ∫Ê©´Âêë<br>‰ª•Áç≤ÂæóÊúÄ‰Ω≥È´îÈ©ó</h2>
    </div>

    <div id="game-container">
        
        <div id="hud">
            <div class="player-stat" id="p1-stats">
                <span class="p1-color">P1</span>
                <span>‚ô• <span id="p1-lives">3</span></span>
                <span>üí£ <span id="p1-bombs">1</span></span>
            </div>
            <div id="level-info">Á¨¨ 1 Èóú</div>
            <div class="player-stat" id="p2-stats" style="opacity: 0;">
                <span class="p2-color">P2</span>
                <span>‚ô• <span id="p2-lives">3</span></span>
                <span>üí£ <span id="p2-bombs">1</span></span>
            </div>
        </div>

        <canvas id="gameCanvas" width="832" height="704"></canvas>
        
        <div id="game-message"></div>

        <div id="main-menu" class="overlay">
            <h1>BOMBER ARENA</h1>
            <h3 style="color:#ffda79; margin-top:-10px; font-family:sans-serif;">BOSS BATTLE</h3>
            
            <div class="settings-box">
                <div class="setting-row">
                    <span>Èõ£Â∫¶ (AI):</span>
                    <button id="btn-diff" class="btn btn-small" onclick="toggleDifficulty()">ÊôÆÈÄö</button>
                </div>
                <div class="setting-row">
                    <span>ÈÅìÂÖ∑ÁòãÁãÇÊ®°Âºè:</span>
                    <button id="btn-frenzy" class="btn btn-small toggle-btn" onclick="toggleFrenzy()">OFF</button>
                </div>
            </div>

            <button class="btn" onclick="startGame('single')">ÂñÆ‰∫∫ÈóñÈóú (Story)</button>
            <button class="btn" onclick="startGame('versus')">Èõô‰∫∫Â∞çÊà∞ (Vs)</button>
            <button class="btn" onclick="requestFullScreen()">ÂÖ®Ëû¢Âπï (Fullscreen)</button>
            <button class="btn" style="border-color: #aaa; color: #aaa;" onclick="openEditor()">ÈóúÂç°Á∑®ËºØÂô® (Editor)</button>
            
            <div class="controls-info">
                <div>
                    <strong class="p1-color">PLAYER 1</strong><br>
                    ÁßªÂãï: <span class="key">‚Üë</span> <span class="key">‚Üì</span> <span class="key">‚Üê</span> <span class="key">‚Üí</span><br>
                    ÁÇ∏ÂΩà: <span class="key">SPACE</span>
                </div>
                <div>
                    <strong class="p2-color">PLAYER 2</strong><br>
                    ÁßªÂãï: <span class="key">W</span> <span class="key">S</span> <span class="key">A</span> <span class="key">D</span><br>
                    ÁÇ∏ÂΩà: <span class="key">SHIFT</span>
                </div>
            </div>
        </div>

        <div id="editor-ui" class="hidden overlay">
            <h2 style="color: var(--accent);">CUSTOM MAP EDITOR</h2>
            <div id="editor-grid"></div>
            <div>
                <button class="btn" onclick="saveAndCloseEditor()">ÂÑ≤Â≠ò</button>
                <button class="btn btn-small" style="background: #444;" onclick="clearEditorMap()">Ê∏ÖÁ©∫</button>
                <button class="btn btn-small" style="background: #444;" onclick="cancelEditor()">ÂèñÊ∂à</button>
            </div>
        </div>

        <div id="game-over" class="overlay hidden">
            <h1 id="go-title">GAME OVER</h1>
            <h2 id="go-reason">Reason</h2>
            <div id="next-level-btn-container" class="hidden">
                <p style="color: #ccc;">ËÉΩÂäõ‰øùÁïôËá≥‰∏ã‰∏ÄÈóúÔºÅ</p>
                <button class="btn" onclick="gameInstance.nextLevel()">‰∏ã‰∏ÄÈóú</button>
            </div>
            <button id="return-menu-btn" class="btn" onclick="returnToMenu()">ÂõûÂà∞ÈÅ∏ÂñÆ</button>
        </div>
    </div>

    <div id="mobile-controls">
        <div class="control-group d-pad-container">
            <div class="d-pad">
                <div class="touch-btn btn-up" data-key="ArrowUp">‚Üë</div>
                <div class="touch-btn btn-left" data-key="ArrowLeft">‚Üê</div>
                <div class="touch-btn btn-right" data-key="ArrowRight">‚Üí</div>
                <div class="touch-btn btn-down" data-key="ArrowDown">‚Üì</div>
            </div>
        </div>
        <div class="control-group action-container">
            <div class="touch-btn btn-bomb-touch" data-key="Space">üí£</div>
        </div>
    </div>

    <script>
        const TILE_SIZE = 64; 
        const ROWS = 11;
        const COLS = 13;
        const CANVAS_WIDTH = COLS * TILE_SIZE;
        const CANVAS_HEIGHT = ROWS * TILE_SIZE;
        
        const TILE_FLOOR = 0;
        const TILE_WALL = 1;
        const TILE_SOFT = 2;
        
        let currentDifficulty = 'normal'; 
        let frenzyMode = false;
        let customMapData = null;

        function requestFullScreen() {
            const el = document.documentElement;
            if (el.requestFullscreen) el.requestFullscreen();
            else if (el.mozRequestFullScreen) el.mozRequestFullScreen();
            else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
            else if (el.msRequestFullscreen) el.msRequestFullscreen();
        }

        const AudioEngine = {
            ctx: null,
            init: function() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
            },
            playTone: function(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playBombPlant: function() { this.playTone(600, 'sine', 0.1); },
            playExplosion: function() { 
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * 0.5;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) { data[i] = Math.random() * 2 - 1; }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                noise.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            },
            playPowerup: function() { 
                this.playTone(1200, 'square', 0.1, 0.05); 
                setTimeout(() => this.playTone(1600, 'square', 0.1, 0.05), 100);
            },
            playDie: function() {
                this.playTone(300, 'sawtooth', 0.5, 0.2);
                setTimeout(() => this.playTone(150, 'sawtooth', 0.5, 0.2), 200);
            },
            playBossHit: function() {
                this.playTone(100, 'sawtooth', 0.3, 0.5);
                setTimeout(() => this.playTone(80, 'sawtooth', 0.3, 0.5), 100);
            },
            playWin: function() {
                this.playTone(400, 'sine', 0.1);
                setTimeout(() => this.playTone(600, 'sine', 0.1), 150);
                setTimeout(() => this.playTone(800, 'sine', 0.3), 300);
            }
        };

        class Game {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.lastTime = 0;
                this.map = [];
                this.entities = [];
                this.bombs = [];
                this.explosions = [];
                this.powerups = [];
                this.mode = 'single';
                this.isRunning = false;
                this.isPaused = false;
                this.roundOver = false;
                this.level = 1;
                this.savedStats = null; 
                
                this.keys = {};
                window.addEventListener('keydown', e => this.keys[e.code] = true);
                window.addEventListener('keyup', e => this.keys[e.code] = false);

                this.setupTouchControls();
            }

            setupTouchControls() {
                const touchBtns = document.querySelectorAll('.touch-btn, .btn-bomb-touch');
                
                const handleTouch = (e, state) => {
                    e.preventDefault(); 
                    const key = e.currentTarget.getAttribute('data-key');
                    if (key) {
                        this.keys[key] = state;
                        if(state) e.currentTarget.classList.add('active');
                        else e.currentTarget.classList.remove('active');
                    }
                };

                touchBtns.forEach(btn => {
                    btn.addEventListener('touchstart', (e) => handleTouch(e, true), {passive: false});
                    btn.addEventListener('touchend', (e) => handleTouch(e, false), {passive: false});
                    btn.addEventListener('mousedown', (e) => handleTouch(e, true));
                    btn.addEventListener('mouseup', (e) => handleTouch(e, false));
                    btn.addEventListener('mouseleave', (e) => handleTouch(e, false));
                });
            }

            reset(mode, keepProgress = false) {
                this.mode = mode;
                this.map = [];
                this.entities = [];
                this.bombs = [];
                this.explosions = [];
                this.powerups = [];
                this.roundOver = false;
                this.isRunning = true;

                if (!keepProgress) {
                    this.level = 1;
                    this.savedStats = null;
                }

                const lvlText = (mode === 'single') ? `Á¨¨ ${this.level} Èóú` : 'Â∞çÊà∞Ê®°Âºè';
                document.getElementById('level-info').innerText = lvlText;

                this.generateMap();
                
                this.p1 = new Player(1, 1, 1, 'Red'); 
                if (this.savedStats) {
                    this.p1.maxBombs = this.savedStats.maxBombs;
                    this.p1.bombRange = this.savedStats.bombRange;
                    this.p1.speed = this.savedStats.speed;
                } else if (frenzyMode) {
                    this.p1.maxBombs = 3;
                    this.p1.bombRange = 3;
                    this.p1.speed += 20;
                }
                this.entities.push(this.p1);

                if (mode === 'versus') {
                    this.p2 = new Player(COLS - 2, ROWS - 2, 2, 'Blue');
                    if (frenzyMode) {
                        this.p2.maxBombs = 3;
                        this.p2.bombRange = 3;
                        this.p2.speed += 20;
                    }
                    this.entities.push(this.p2);
                    document.getElementById('p2-stats').style.opacity = 1;
                } else {
                    let enemyCount = 2 + this.level;
                    if (currentDifficulty === 'hard') enemyCount += 2;
                    enemyCount = Math.min(enemyCount, 12);
                    this.spawnEnemies(enemyCount);
                    document.getElementById('p2-stats').style.opacity = 0;
                }

                const msg = (mode === 'single') ? `Á¨¨ ${this.level} Èóú` : "READY?";
                const msgEl = document.getElementById('game-message');
                if(msgEl) msgEl.innerText = msg;
                setTimeout(() => {
                    if(msgEl) msgEl.innerText = "";
                }, 2000);
                
                requestAnimationFrame(t => this.loop(t));
            }

            generateMap() {
                if (customMapData) {
                    this.map = JSON.parse(JSON.stringify(customMapData));
                    return;
                }

                for (let r = 0; r < ROWS; r++) {
                    const row = [];
                    for (let c = 0; c < COLS; c++) {
                        if (r === 0 || c === 0 || r === ROWS - 1 || c === COLS - 1) {
                            row.push(TILE_WALL);
                        } else if (r % 2 === 0 && c % 2 === 0) {
                            row.push(TILE_WALL);
                        } else {
                            const isP1Safe = (r < 3 && c < 3);
                            const isP2Safe = (r > ROWS - 4 && c > COLS - 4);
                            if (!isP1Safe && !isP2Safe && Math.random() < 0.1) {
                                row.push(TILE_SOFT);
                            } else {
                                row.push(TILE_FLOOR);
                            }
                        }
                    }
                    this.map.push(row);
                }
            }

            spawnEnemies(count) {
                let spawned = 0;
                let attempts = 0;
                const speedMultiplier = 1 + (this.level - 1) * 0.05;

                // Spawn 1 Boss
                let bossSpawned = false;

                while (spawned < count && attempts < 200) {
                    let r = Math.floor(Math.random() * ROWS);
                    let c = Math.floor(Math.random() * COLS);
                    
                    if (this.map[r][c] === TILE_FLOOR && r > 4 && c > 4) {
                        let type = 'normal';
                        // Determine type
                        if (currentDifficulty === 'easy') type = 'easy';
                        else if (currentDifficulty === 'hard') type = 'hard';
                        
                        let isBoss = false;
                        if (!bossSpawned) {
                            isBoss = true;
                            bossSpawned = true;
                        }

                        const enemy = new Enemy(c, r, type, isBoss);
                        if (!isBoss) {
                            enemy.speed *= speedMultiplier;
                        } else {
                            // Boss base speed
                            enemy.speed = 130 + (this.level * 5); 
                        }
                        
                        this.entities.push(enemy);
                        spawned++;
                    }
                    attempts++;
                }
            }

            loop(timestamp) {
                if (!this.isRunning) return;
                const dt = (timestamp - this.lastTime) / 1000;
                this.lastTime = timestamp;

                if (!this.isPaused && !this.roundOver) {
                    this.update(dt);
                }
                this.draw();
                requestAnimationFrame(t => this.loop(t));
            }

            update(dt) {
                this.entities = this.entities.filter(e => e.alive);
                this.entities.forEach(e => e.update(dt, this));

                this.bombs = this.bombs.filter(b => !b.exploded);
                this.bombs.forEach(b => b.update(dt, this));

                this.explosions = this.explosions.filter(e => e.active);
                this.explosions.forEach(e => e.update(dt));

                if (this.mode === 'versus') {
                    const p1Alive = this.entities.find(e => e.id === 1 && e.alive);
                    const p2Alive = this.entities.find(e => e.id === 2 && e.alive);
                    if (!p1Alive || !p2Alive) {
                        this.endGame(p1Alive ? "Player 1 Wins!" : (p2Alive ? "Player 2 Wins!" : "Draw!"), false);
                    }
                } else {
                    const p1 = this.entities.find(e => e.id === 1);
                    const enemies = this.entities.filter(e => e.type === 'enemy');
                    
                    if (!p1 || !p1.alive) {
                        this.endGame("Game Over!", false);
                    } else if (enemies.length === 0) {
                        this.levelCleared();
                    }
                }
                this.updateHUD();
            }

            updateHUD() {
                if (this.p1) {
                    document.getElementById('p1-lives').innerText = this.p1.lives;
                    document.getElementById('p1-bombs').innerText = this.p1.maxBombs;
                }
                if (this.p2) {
                    document.getElementById('p2-lives').innerText = this.p2.lives;
                    document.getElementById('p2-bombs').innerText = this.p2.maxBombs;
                }
            }

            draw() {
                this.ctx.fillStyle = '#4cd137';
                this.ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

                for (let r = 0; r < ROWS; r++) {
                    for (let c = 0; c < COLS; c++) {
                        const tile = this.map[r][c];
                        const x = c * TILE_SIZE;
                        const y = r * TILE_SIZE;

                        if (tile === TILE_WALL) {
                            this.ctx.fillStyle = '#718093';
                            this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                            this.ctx.fillStyle = '#a4b0be';
                            this.ctx.fillRect(x+2, y+2, TILE_SIZE-4, 10);
                            this.ctx.fillRect(x+2, y+2, 10, TILE_SIZE-4);
                            this.ctx.fillStyle = 'rgba(0,0,0,0.3)';
                            this.ctx.fillRect(x+5, y+55, TILE_SIZE-10, 5);
                        } else if (tile === TILE_SOFT) {
                            this.ctx.fillStyle = '#e1b12c';
                            this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                            this.ctx.fillStyle = '#fbc531';
                            this.ctx.fillRect(x+4, y+4, TILE_SIZE-8, TILE_SIZE-8);
                            this.ctx.fillStyle = '#c23616'; 
                            this.ctx.fillRect(x, y+30, TILE_SIZE, 4);
                            this.ctx.fillRect(x+30, y, 4, 30);
                            this.ctx.fillRect(x+10, y+30, 4, 34);
                        }
                    }
                }

                this.powerups.forEach(p => {
                    const x = p.c * TILE_SIZE + TILE_SIZE/2;
                    const y = p.r * TILE_SIZE + TILE_SIZE/2;
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 18, 0, Math.PI*2);
                    if (p.type === 'range') {
                        this.ctx.fillStyle = '#fbc531'; 
                        this.ctx.fill();
                        this.ctx.fillStyle = 'black';
                        this.ctx.font = '20px Arial';
                        this.ctx.fillText('üî•', x-10, y+7);
                    } else if (p.type === 'speed') {
                        this.ctx.fillStyle = '#00a8ff'; 
                        this.ctx.fill();
                        this.ctx.fillStyle = 'black';
                        this.ctx.font = '20px Arial';
                        this.ctx.fillText('‚ö°', x-10, y+7);
                    } else if (p.type === 'bomb') {
                        this.ctx.fillStyle = '#2f3640'; 
                        this.ctx.fill();
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = '20px Arial';
                        this.ctx.fillText('üí£', x-10, y+7);
                    }
                });

                this.bombs.forEach(b => {
                    const x = b.c * TILE_SIZE + TILE_SIZE/2;
                    const y = b.r * TILE_SIZE + TILE_SIZE/2;
                    const scale = 1 + Math.sin(Date.now() / 100) * 0.15; 
                    this.ctx.fillStyle = '#2f3542';
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 22 * scale, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.fillStyle = '#57606f';
                    this.ctx.beginPath();
                    this.ctx.arc(x-5, y-5, 6 * scale, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.strokeStyle = '#ff6b6b';
                    this.ctx.lineWidth = 4;
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, y-15);
                    this.ctx.lineTo(x+10, y-25);
                    this.ctx.stroke();
                });

                this.entities.forEach(e => e.draw(this.ctx));

                this.explosions.forEach(e => {
                    const x = e.c * TILE_SIZE;
                    const y = e.r * TILE_SIZE;
                    this.ctx.fillStyle = Math.random() > 0.5 ? '#ff9f43' : '#ee5253';
                    this.ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    this.ctx.fillStyle = '#fff';
                    this.ctx.globalAlpha = 0.7;
                    this.ctx.fillRect(x+10, y+10, TILE_SIZE-20, TILE_SIZE-20);
                    this.ctx.globalAlpha = 1.0;
                });
            }

            levelCleared() {
                this.roundOver = true;
                AudioEngine.playWin();
                
                this.savedStats = {
                    maxBombs: this.p1.maxBombs,
                    bombRange: this.p1.bombRange,
                    speed: this.p1.speed
                };

                setTimeout(() => {
                    document.getElementById('game-over').classList.remove('hidden');
                    document.getElementById('go-title').innerText = "ÈóúÂç°ÈÄöÈÅéÔºÅ";
                    document.getElementById('go-title').style.color = "#44bd32";
                    document.getElementById('go-reason').innerText = `ÂÆåÊàêÁ¨¨ ${this.level} Èóú`;
                    
                    document.getElementById('next-level-btn-container').classList.remove('hidden');
                    document.getElementById('return-menu-btn').classList.add('hidden');
                    
                    this.isRunning = false;
                }, 1000);
            }

            nextLevel() {
                this.level++;
                document.getElementById('game-over').classList.add('hidden');
                this.reset('single', true); 
            }

            endGame(reason, win) {
                this.roundOver = true;
                setTimeout(() => {
                    document.getElementById('game-over').classList.remove('hidden');
                    document.getElementById('go-title').innerText = "GAME OVER";
                    document.getElementById('go-title').style.color = "#c23616";
                    document.getElementById('go-reason').innerText = reason;
                    
                    document.getElementById('next-level-btn-container').classList.add('hidden');
                    document.getElementById('return-menu-btn').classList.remove('hidden');
                    
                    this.isRunning = false;
                }, 1000);
            }
        }

        class Entity {
            constructor(c, r, type) {
                this.x = c * TILE_SIZE;
                this.y = r * TILE_SIZE;
                this.w = TILE_SIZE - 20;
                this.h = TILE_SIZE - 20;
                this.type = type;
                this.alive = true;
                this.speed = 200;
                this.offX = (TILE_SIZE - this.w) / 2;
                this.offY = (TILE_SIZE - this.h) / 2;
            }

            getGridPos() {
                return {
                    c: Math.floor((this.x + TILE_SIZE/2) / TILE_SIZE),
                    r: Math.floor((this.y + TILE_SIZE/2) / TILE_SIZE)
                };
            }

            checkCollision(newX, newY, game) {
                const points = [
                    {x: newX + this.offX, y: newY + this.offY},
                    {x: newX + this.offX + this.w, y: newY + this.offY},
                    {x: newX + this.offX, y: newY + this.offY + this.h},
                    {x: newX + this.offX + this.w, y: newY + this.offY + this.h}
                ];

                for (let p of points) {
                    const c = Math.floor(p.x / TILE_SIZE);
                    const r = Math.floor(p.y / TILE_SIZE);
                    if (r < 0 || c < 0 || r >= ROWS || c >= COLS) return {collided: true, type: 'bounds'};
                    if (game.map[r][c] === TILE_WALL) return {collided: true, type: 'wall'};
                    if (game.map[r][c] === TILE_SOFT) return {collided: true, type: 'soft'};

                    const bomb = game.bombs.find(b => b.r === r && b.c === c && !b.exploded);
                    if (bomb) {
                        if (bomb.passableEntities.includes(this)) continue; 
                        return {collided: true, type: 'bomb'};
                    }
                }
                return {collided: false};
            }
        }

        class Player extends Entity {
            constructor(c, r, id, colorName) {
                super(c, r, 'player');
                this.id = id;
                this.color = colorName === 'Red' ? '#ff6b6b' : '#48dbfb';
                this.maxBombs = 1;
                this.bombRange = 2;
                this.placedBombs = 0;
                this.lives = 3;
                this.invincible = 0;
            }

            update(dt, game) {
                if (this.invincible > 0) this.invincible -= dt;
                let dx = 0, dy = 0;

                if (this.id === 1) {
                    if (game.keys['ArrowUp']) dy = -1;
                    if (game.keys['ArrowDown']) dy = 1;
                    if (game.keys['ArrowLeft']) dx = -1;
                    if (game.keys['ArrowRight']) dx = 1;
                    if (game.keys['Space']) this.placeBomb(game);
                } else {
                    if (game.keys['KeyW']) dy = -1;
                    if (game.keys['KeyS']) dy = 1;
                    if (game.keys['KeyA']) dx = -1;
                    if (game.keys['KeyD']) dx = 1;
                    if (game.keys['ShiftLeft']) this.placeBomb(game);
                }

                if (dx !== 0 || dy !== 0) {
                    if (dx !== 0 && dy !== 0) { dx *= 0.707; dy *= 0.707; }
                    const nextX = this.x + dx * this.speed * dt;
                    const nextY = this.y + dy * this.speed * dt;
                    if (!this.checkCollision(nextX, this.y, game).collided) this.x = nextX;
                    if (!this.checkCollision(this.x, nextY, game).collided) this.y = nextY;
                }

                const center = this.getGridPos();
                const pIndex = game.powerups.findIndex(p => p.c === center.c && p.r === center.r);
                if (pIndex !== -1) {
                    this.collectPowerup(game.powerups[pIndex]);
                    game.powerups.splice(pIndex, 1);
                    AudioEngine.playPowerup();
                }

                if (this.invincible <= 0) {
                    const hit = game.explosions.some(e => e.c === center.c && e.r === center.r);
                    const enemyHit = game.entities.some(e => e.type === 'enemy' && Math.abs(e.x - this.x) < 30 && Math.abs(e.y - this.y) < 30);
                    if (hit || enemyHit) this.die();
                }
            }

            collectPowerup(p) {
                if (p.type === 'range') this.bombRange++;
                if (p.type === 'speed') this.speed = Math.min(this.speed + 50, 450); 
                if (p.type === 'bomb') this.maxBombs++;
            }

            placeBomb(game) {
                if (this.placedBombs >= this.maxBombs) return;
                const pos = this.getGridPos();
                if (game.bombs.some(b => b.c === pos.c && b.r === pos.r)) return;
                const bomb = new Bomb(pos.c, pos.r, this.bombRange, this, game);
                game.bombs.push(bomb);
                this.placedBombs++;
                AudioEngine.playBombPlant();
            }

            die() {
                if (this.lives > 0) {
                    this.lives--;
                    this.invincible = 2;
                    AudioEngine.playDie();
                    if (this.lives <= 0) this.alive = false;
                }
            }

            draw(ctx) {
                if (this.invincible > 0 && Math.floor(Date.now() / 100) % 2 === 0) return;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x + TILE_SIZE/2, this.y + TILE_SIZE/2, this.w/2, 0, Math.PI*2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.fillRect(this.x + 15, this.y + 15, 10, 10);
                ctx.fillRect(this.x + 35, this.y + 15, 10, 10);
            }
        }

        class Enemy extends Entity {
            constructor(c, r, difficulty, isBoss = false) {
                super(c, r, 'enemy');
                this.difficulty = difficulty;
                this.dir = {x: 1, y: 0};
                this.isBoss = isBoss;
                
                this.maxBombs = isBoss ? 2 : 0; // Only boss has bombs
                this.placedBombs = 0;
                this.bombRange = (difficulty === 'hard' || isBoss) ? 3 : 2; 
                this.bombCooldown = 0; 
                this.escapeTime = 0;
                this.lives = isBoss ? 3 : 1;
                this.invincible = 0;
                
                if (this.difficulty === 'easy') {
                    this.speed = 80;
                }
                else if (this.difficulty === 'normal') {
                    this.speed = 120;
                }
                else if (this.difficulty === 'hard') {
                    this.speed = 170;
                }
                
                if (this.isBoss) {
                    this.canBomb = true;
                    this.speed = 140; // Base speed for boss
                } else {
                    this.canBomb = false;
                }
            }

            update(dt, game) {
                if (this.invincible > 0) this.invincible -= dt;
                if (this.bombCooldown > 0) this.bombCooldown -= dt;
                if (this.escapeTime > 0) this.escapeTime -= dt;

                // Boss Special: Rage Mode (Low HP)
                if (this.isBoss && this.lives < 3) {
                    // Angry mode: faster speed, reduced cooldown
                    this.speed = 220; 
                }

                // AI Decision Making
                if (this.escapeTime <= 0) {
                    // Boss seeks player or wanders
                    if (this.isBoss || this.difficulty === 'hard') {
                        const p1 = game.entities.find(e => e.id === 1 && e.alive);
                        if (p1 && Math.random() < 0.05) {
                            if (Math.abs(p1.x - this.x) > Math.abs(p1.y - this.y)) {
                                this.dir = (p1.x > this.x) ? {x:1, y:0} : {x:-1, y:0};
                            } else {
                                this.dir = (p1.y > this.y) ? {x:0, y:1} : {x:0, y:-1};
                            }
                        }
                    } else if (Math.random() < 0.02) {
                        this.pickRandomDirection();
                    }
                }

                // Movement
                const nextX = this.x + this.dir.x * this.speed * dt;
                const nextY = this.y + this.dir.y * this.speed * dt;
                const collision = this.checkCollision(nextX, nextY, game);

                if (collision.collided) {
                    this.pickRandomDirection();
                } else {
                    this.x = nextX;
                    this.y = nextY;
                    
                    // Bomb Logic (Only Boss)
                    if (this.isBoss && this.canBomb && this.bombCooldown <= 0 && this.escapeTime <= 0) {
                        const p1 = game.entities.find(e => e.id === 1 && e.alive);
                        if (p1) {
                            const dist = Math.abs(p1.x - this.x) + Math.abs(p1.y - this.y);
                            // Attack if player is close or just randomly to create chaos
                            let bombChance = this.lives < 3 ? 0.08 : 0.03; // Higher chance when angry
                            if (dist < TILE_SIZE * 4 && Math.random() < bombChance) {
                                // Smart Check: Don't bomb if trapped
                                const gridPos = this.getGridPos();
                                const openPaths = this.countOpenPaths(game, gridPos);
                                if (openPaths > 0) {
                                    this.placeBomb(game);
                                }
                            }
                        }
                    }
                }

                // Powerup Collection (Boss Only)
                if (this.isBoss) {
                    const center = this.getGridPos();
                    const pIndex = game.powerups.findIndex(p => p.c === center.c && p.r === center.r);
                    if (pIndex !== -1) {
                        this.collectPowerup(game.powerups[pIndex]);
                        game.powerups.splice(pIndex, 1);
                        AudioEngine.playPowerup();
                    }
                }

                // Check Damage
                if (this.invincible <= 0) {
                    const pos = this.getGridPos();
                    if (game.explosions.some(e => e.c === pos.c && e.r === pos.r)) {
                        this.takeDamage();
                    }
                }
            }

            takeDamage() {
                if (this.lives > 0) {
                    this.lives--;
                    this.invincible = 2; // Invincible frames
                    AudioEngine.playBossHit();
                    if (this.lives <= 0) {
                        this.alive = false;
                        AudioEngine.playDie();
                    }
                }
            }

            collectPowerup(p) {
                if (p.type === 'range') this.bombRange++;
                if (p.type === 'speed') this.speed = Math.min(this.speed + 30, 400); 
                if (p.type === 'bomb') this.maxBombs++;
            }

            pickRandomDirection() {
                const dirs = [{x:1,y:0}, {x:-1,y:0}, {x:0,y:1}, {x:0,y:-1}];
                this.dir = dirs[Math.floor(Math.random() * dirs.length)];
            }

            countOpenPaths(game, pos) {
                let count = 0;
                const dirs = [{r:0, c:1}, {r:0, c:-1}, {r:1, c:0}, {r:-1, c:0}];
                dirs.forEach(d => {
                    const nr = pos.r + d.r;
                    const nc = pos.c + d.c;
                    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS && 
                        game.map[nr][nc] === TILE_FLOOR &&
                        !game.bombs.some(b => b.r === nr && b.c === nc)) {
                        count++;
                    }
                });
                return count;
            }

            placeBomb(game) {
                const pos = this.getGridPos();
                if (game.bombs.some(b => b.c === pos.c && b.r === pos.r)) return;
                
                const bomb = new Bomb(pos.c, pos.r, this.bombRange, this, game);
                game.bombs.push(bomb);
                this.placedBombs++;
                // Rage mode has lower cooldown
                this.bombCooldown = this.lives < 3 ? 1.5 : 3; 
                AudioEngine.playBombPlant();
                
                // Smart Escape logic
                const neighbors = [
                    {x: 1, y: 0, r: pos.r, c: pos.c + 1},
                    {x: -1, y: 0, r: pos.r, c: pos.c - 1},
                    {x: 0, y: 1, r: pos.r + 1, c: pos.c},
                    {x: 0, y: -1, r: pos.r - 1, c: pos.c}
                ];
                
                const validEscapes = neighbors.filter(n => 
                    n.r >= 0 && n.r < ROWS && n.c >= 0 && n.c < COLS && 
                    game.map[n.r][n.c] === TILE_FLOOR &&
                    !game.bombs.some(b => b.r === n.r && b.c === n.c)
                );

                if (validEscapes.length > 0) {
                    const escape = validEscapes[Math.floor(Math.random() * validEscapes.length)];
                    this.dir = {x: escape.x, y: escape.y};
                    this.escapeTime = 1.0; 
                } else {
                    this.dir.x *= -1;
                    this.dir.y *= -1;
                }
            }

            draw(ctx) {
                // Flash if invincible
                if (this.invincible > 0 && Math.floor(Date.now() / 50) % 2 === 0) return;

                if (this.isBoss) {
                    // Boss Color
                    ctx.fillStyle = this.lives < 3 ? '#e056fd' : '#8e44ad'; // Purple / Light Purple when angry
                } else {
                    if (this.difficulty === 'easy') ctx.fillStyle = '#1dd1a1'; 
                    else if (this.difficulty === 'normal') ctx.fillStyle = '#ff9f43'; 
                    else ctx.fillStyle = '#ee5253'; 
                }

                ctx.beginPath();
                // Make Boss Bigger
                const sizeMod = this.isBoss ? 4 : 0;
                const w = Math.sin(Date.now() / 100) * 2;
                ctx.arc(this.x + TILE_SIZE/2, this.y + TILE_SIZE/2, (this.w/2) + sizeMod - 2 + w, 0, Math.PI*2);
                ctx.fill();
                
                // Angry eyebrows
                if (this.difficulty === 'hard' || (this.isBoss && this.lives < 3)) {
                    ctx.fillStyle = '#000';
                    ctx.beginPath();
                    ctx.moveTo(this.x + 15 - sizeMod, this.y + 25 - sizeMod);
                    ctx.lineTo(this.x + 25 - sizeMod, this.y + 30 - sizeMod);
                    ctx.moveTo(this.x + 45 + sizeMod, this.y + 25 - sizeMod);
                    ctx.lineTo(this.x + 35 + sizeMod, this.y + 30 - sizeMod);
                    ctx.stroke();
                }
                
                // Draw Crown for Boss
                if (this.isBoss) {
                    ctx.fillStyle = 'gold';
                    ctx.beginPath();
                    ctx.moveTo(this.x + 20, this.y + 10);
                    ctx.lineTo(this.x + 32, this.y + 20);
                    ctx.lineTo(this.x + 44, this.y + 10);
                    ctx.lineTo(this.x + 44, this.y + 25);
                    ctx.lineTo(this.x + 20, this.y + 25);
                    ctx.fill();
                }

                ctx.fillStyle = '#000';
                ctx.fillRect(this.x + 20, this.y + 25, 5, 5);
                ctx.fillRect(this.x + 40, this.y + 25, 5, 5);
            }
        }

        class Bomb {
            constructor(c, r, range, owner, game) {
                this.c = c;
                this.r = r;
                this.range = range;
                this.owner = owner;
                this.timer = 2.0;
                this.exploded = false;
                this.passableEntities = [];
                if (game) {
                    this.passableEntities = game.entities.filter(e => {
                        const ex = e.x + e.offX, ey = e.y + e.offY;
                        const bx = c * TILE_SIZE, by = r * TILE_SIZE;
                        return (ex < bx + TILE_SIZE && ex + e.w > bx && ey < by + TILE_SIZE && ey + e.h > by);
                    });
                }
            }

            update(dt, game) {
                this.timer -= dt;
                if (this.passableEntities.length > 0) {
                    const bx = this.c * TILE_SIZE, by = this.r * TILE_SIZE;
                    this.passableEntities = this.passableEntities.filter(e => {
                        const ex = e.x + e.offX, ey = e.y + e.offY;
                        return (ex < bx + TILE_SIZE && ex + e.w > bx && ey < by + TILE_SIZE && ey + e.h > by);
                    });
                }
                if (game.explosions.some(e => e.c === this.c && e.r === this.r)) this.timer = 0;
                if (this.timer <= 0) this.explode(game);
            }

            explode(game) {
                this.exploded = true;
                this.owner.placedBombs--;
                AudioEngine.playExplosion();
                game.explosions.push(new Explosion(this.c, this.r));
                const dirs = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];
                
                dirs.forEach(d => {
                    for (let i = 1; i <= this.range; i++) {
                        const nc = this.c + (d.x * i);
                        const nr = this.r + (d.y * i);
                        if (nc < 0 || nc >= COLS || nr < 0 || nr >= ROWS) break;
                        if (game.map[nr][nc] === TILE_WALL) break;
                        game.explosions.push(new Explosion(nc, nr));
                        
                        if (game.map[nr][nc] === TILE_SOFT) {
                            game.map[nr][nc] = TILE_FLOOR;
                            const dropChance = frenzyMode ? 0.9 : 0.5; 
                            if (Math.random() < dropChance) {
                                const types = ['range', 'speed', 'bomb'];
                                const type = types[Math.floor(Math.random() * types.length)];
                                game.powerups.push({c: nc, r: nr, type: type});
                            }
                            break;
                        }
                    }
                });
            }
        }

        class Explosion {
            constructor(c, r) {
                this.c = c;
                this.r = r;
                this.timer = 0.5;
                this.active = true;
            }
            update(dt) {
                this.timer -= dt;
                if (this.timer <= 0) this.active = false;
            }
        }

        const gameInstance = new Game();

        const diffLabels = { 'easy': 'Á∞°ÂñÆ', 'normal': 'ÊôÆÈÄö', 'hard': 'Âõ∞Èõ£' };
        document.getElementById('btn-diff').innerText = diffLabels[currentDifficulty];

        function toggleDifficulty() {
            if (currentDifficulty === 'easy') currentDifficulty = 'normal';
            else if (currentDifficulty === 'normal') currentDifficulty = 'hard';
            else currentDifficulty = 'easy';
            
            const btn = document.getElementById('btn-diff');
            btn.innerText = diffLabels[currentDifficulty];
            btn.style.color = currentDifficulty === 'hard' ? '#ff5252' : '#fff';
        }

        function toggleFrenzy() {
            frenzyMode = !frenzyMode;
            const btn = document.getElementById('btn-frenzy');
            if (frenzyMode) {
                btn.innerText = "ON";
                btn.classList.add('active');
            } else {
                btn.innerText = "OFF";
                btn.classList.remove('active');
            }
        }

        function startGame(mode) {
            AudioEngine.init();
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('game-over').classList.add('hidden');
            gameInstance.reset(mode);
        }

        function returnToMenu() {
            document.getElementById('game-over').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
            gameInstance.isRunning = false;
        }

        let editorMap = [];

        function openEditor() {
            document.getElementById('main-menu').classList.add('hidden');
            document.getElementById('editor-ui').classList.remove('hidden');
            initEditorGrid();
        }

        function initEditorGrid() {
            const grid = document.getElementById('editor-grid');
            grid.innerHTML = '';
            
            if (customMapData) {
                editorMap = JSON.parse(JSON.stringify(customMapData));
            } else {
                editorMap = [];
                for (let r = 0; r < ROWS; r++) {
                    const row = [];
                    for (let c = 0; c < COLS; c++) {
                        if (r === 0 || c === 0 || r === ROWS - 1 || c === COLS - 1) row.push(TILE_WALL);
                        else if (r % 2 === 0 && c % 2 === 0) row.push(TILE_WALL);
                        else row.push(TILE_FLOOR);
                    }
                    editorMap.push(row);
                }
            }

            for (let r = 0; r < ROWS; r++) {
                for (let c = 0; c < COLS; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('editor-cell');
                    cell.dataset.r = r;
                    cell.dataset.c = c;
                    
                    const isSpawn = (r===1 && c===1) || (r===ROWS-2 && c===COLS-2);
                    if(isSpawn) cell.classList.add('cell-spawn');

                    cell.onclick = () => {
                        if (isSpawn) return;
                        toggleEditorTile(r, c, cell);
                    };
                    
                    updateCellVisual(cell, editorMap[r][c]);
                    grid.appendChild(cell);
                }
            }
        }

        function toggleEditorTile(r, c, cell) {
            let val = editorMap[r][c];
            val = (val + 1) % 3;
            editorMap[r][c] = val;
            updateCellVisual(cell, val);
        }

        function updateCellVisual(cell, val) {
            cell.classList.remove('cell-floor', 'cell-wall', 'cell-soft');
            if (val === TILE_FLOOR) cell.classList.add('cell-floor');
            else if (val === TILE_WALL) cell.classList.add('cell-wall');
            else if (val === TILE_SOFT) cell.classList.add('cell-soft');
        }

        function saveAndCloseEditor() {
            customMapData = JSON.parse(JSON.stringify(editorMap));
            document.getElementById('editor-ui').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
        }

        function clearEditorMap() {
             for (let r = 1; r < ROWS - 1; r++) {
                for (let c = 1; c < COLS - 1; c++) {
                     if (!((r===1 && c===1) || (r===ROWS-2 && c===COLS-2))) {
                         editorMap[r][c] = TILE_FLOOR;
                     }
                }
            }
            initEditorGrid(); 
        }

        function cancelEditor() {
            document.getElementById('editor-ui').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
        }

    </script>
</body>
</html>
